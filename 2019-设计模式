设计模式的六大原则：
    1. 开闭原则 -- Open Close Principle
    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果

    2. 里氏替换原则 -- Liskov Substitution Principle
    主张使用继承和多态，子类的能力必须大于等于父类
    假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以
    如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的
    还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类，而不能声明抛出父类没有声明的异常

    3. 依赖倒转原则 -- Dependence Inversion Principle
    面向接口编程，依赖于抽象而不依赖于具体

    4. 接口隔离原则 -- Interface Segregation Principle
    一个接口只做一件事情，降低耦合

    5. 迪米特法则（最少知道原则） -- Demeter Principle
    一个实体应当尽量少的与其他实体之间发生相互作用

    6. 合成复用原则 -- Composite Reuse Principle
    尽量使用合成/聚合的方式，而不是使用继承

创建型模式 -- 有五种
    工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

    工厂方法模式有三种: 简单工厂模式、多个工厂方法模式、静态工厂方法模式
        普通工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建
        多个工厂方法模式，是对普通工厂方法模式的改进，多个工厂方法模式就是提供多个工厂方法，分别创建对象
        静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可

    抽象工厂模式:
        工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序
        必须对工厂类进行修改，这违背了闭包原则。我们来看看抽象工厂模式：
        创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码

    单例模式有三种: 饿汉模式、懒汉模式
        推荐的方式、线程安全的方式：静态代码块、静态内部类、枚举、双重检查锁

    建造者模式:
        是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
        字面看来非常抽象，实际上它也十分抽象
        建造者模式通常包括下面几个角色：
        Builder -- 给出一个抽象接口，以规范对象的各个组成成分的建造
                 这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建
        ConcreteBuilder -- 实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建
                 在建造过程完成后，提供产品的实例
        Director -- 调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息
                 只负责保证对象各部分完整创建或按某种顺序创建
        Product -- 要创建的复杂对象

    原型模式:
        原型模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象
        说道复制对象，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念
            浅复制 -- 将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的
            深复制 -- 将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的
            简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底

结构型模式 -- 有七种
    适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

    适配器模式有三种: 类的适配器模式、对象的适配器模式、接口的适配器模式



1.观察者模式.....
	有时候称之为，发布/订阅模式，定义了一种一对多的依赖关系，多个观察者对象同事监听某一个主题对象，当这个主题对象发生改变时，会通知所有的观察者对象，
	使它们能够自己更新自己
	模式中的角色：
	a 抽象主题
	aa 具体主题
	b 抽象观察者
	bb 具体的观察者

	主题对象中有个集合存储多个观察者。所以有添加和删除观察者的方法。还有一个 notify方法，内部遍历所有的观察者对象，使观察者对象调用自己的update方法。
	观察者对象中 有一个 update方法，用于更新自己。

    2.代理模式...装饰者模式的区别...
	代理模式中，代理类  对 被代理的对象具有控制权....决定其执行或是不执行.....
	装饰模式中，装饰类 对 代理类对象没有控制权.... 但是可以加强被装饰对象的功能......

    3.适配模式.....(Adapter)
	将一个类的接口转换成客户希望的另一个接口，由于接口不兼容而不能一起工作的那些类可以在一起工作。
	适配器类 --->实现旧的接口，组合新的接口。

    4.工厂模式：主要是为创建对象提供过渡接口，隐藏具体的创建细节，提高灵活性的目的
	一：简单工厂
	抽象的产品：car{}
	具体的产品：AoDi implements car{}
	工厂类：simpleFactory{
			createCar(type)

			}
	二：工厂方法
	抽象的产品：car{}
	具体的产品：AoDi implements car{}
	抽象工厂类：interface Factory{
			createCar()
		      }
	具体工厂类：AoDiFactory implements Factory{
			createCar(){
				new AoDi();
			}
			}
		BYDFactory implements Factory{
			createCar(){
				new byd();
			}
			}


	三：抽象工厂
	不同的抽象产品组（多个组件）
	interface Factory{
			createCar()
			createSeat()
		      }
	不同的工厂：A类汽车工厂：createCar( new CarA)
				  createSeat(new SeatA)
		    B类汽车工厂：createCar( new CarB)
				  createSeat(new SeatB)



